package phaser.physics.arcade;

@:native("Phaser.Physics.Arcade.World")
extern class World extends phaser.events.EventEmitter {
    public function new(scene:phaser.Scene, config:ArcadeWorldConfig);
    public var scene:phaser.Scene;
    public var bodies:Dynamic;
    public var staticBodies:Dynamic;
    public var pendingDestroy:Dynamic;
    public var colliders:Dynamic;
    public var gravity:phaser.math.Vector2;
    public var bounds:phaser.geom.Rectangle;
    public var checkCollision:CheckCollisionObject;
    public var fps:Float;
    public var stepsLastFrame:Float;
    public var timeScale:Dynamic;
    public var OVERLAP_BIAS:Float;
    public var TILE_BIAS:Float;
    public var forceX:Bool;
    public var isPaused:Bool;
    public var drawDebug:Bool;
    public var debugGraphic:phaser.gameobjects.Graphics;
    public var defaults:ArcadeWorldDefaults;
    public var maxEntries:Int;
    public var useTree:Bool;
    public var tree:phaser.structs.RTree;
    public var staticTree:phaser.structs.RTree;
    public var treeMinMax:ArcadeWorldTreeMinMax;
    public function enable(object:Dynamic, ?bodyType:Int):Void;
    public function enableBody(object:phaser.gameobjects.GameObject, ?bodyType:Int):phaser.gameobjects.GameObject;
    public function add(body:Dynamic):phaser.physics.arcade.Body;
    public function disable(object:Dynamic):Void;
    public function disableBody(body:Dynamic):Void;
    public function remove(body:Dynamic):Void;
    public function createDebugGraphic():phaser.gameobjects.Graphics;
    public function setBounds(x:Float, y:Float, width:Float, height:Float, ?checkLeft:Bool, ?checkRight:Bool, ?checkUp:Bool, ?checkDown:Bool):phaser.physics.arcade.World;
    public function setBoundsCollision(?left:Bool, ?right:Bool, ?up:Bool, ?down:Bool):phaser.physics.arcade.World;
    public function pause():phaser.physics.arcade.World;
    public function resume():phaser.physics.arcade.World;
    public function addCollider(object1:ArcadeColliderType, object2:ArcadeColliderType, ?collideCallback:ArcadePhysicsCallback, ?processCallback:ArcadePhysicsCallback, ?callbackContext:Dynamic):phaser.physics.arcade.Collider;
    public function addOverlap(object1:ArcadeColliderType, object2:ArcadeColliderType, ?collideCallback:ArcadePhysicsCallback, ?processCallback:ArcadePhysicsCallback, ?callbackContext:Dynamic):phaser.physics.arcade.Collider;
    public function removeCollider(collider:phaser.physics.arcade.Collider):phaser.physics.arcade.World;
    public function setFPS(framerate:Int):Dynamic;
    public function update(time:Float, delta:Float):Void;
    public function step(delta:Float):Void;
    public function postUpdate():Void;
    public function updateMotion(body:phaser.physics.arcade.Body, delta:Float):Void;
    public function computeAngularVelocity(body:phaser.physics.arcade.Body, delta:Float):Void;
    public function computeVelocity(body:phaser.physics.arcade.Body, delta:Float):Void;
    public function separate(body1:phaser.physics.arcade.Body, body2:phaser.physics.arcade.Body, ?processCallback:ArcadePhysicsCallback, ?callbackContext:Dynamic, ?overlapOnly:Bool):Bool;
    public function separateCircle(body1:phaser.physics.arcade.Body, body2:phaser.physics.arcade.Body, ?overlapOnly:Bool, bias:Float):Bool;
    public function intersects(body1:phaser.physics.arcade.Body, body2:phaser.physics.arcade.Body):Bool;
    public function circleBodyIntersects(circle:phaser.physics.arcade.Body, body:phaser.physics.arcade.Body):Bool;
    public function overlap(object1:ArcadeColliderType, ?object2:ArcadeColliderType, ?overlapCallback:ArcadePhysicsCallback, ?processCallback:ArcadePhysicsCallback, ?callbackContext:Dynamic):Bool;
    public function collide(object1:ArcadeColliderType, ?object2:ArcadeColliderType, ?collideCallback:ArcadePhysicsCallback, ?processCallback:ArcadePhysicsCallback, ?callbackContext:Dynamic):Bool;
    public function collideObjects(object1:ArcadeColliderType, ?object2:ArcadeColliderType, collideCallback:ArcadePhysicsCallback, processCallback:ArcadePhysicsCallback, callbackContext:Dynamic, overlapOnly:Bool):Bool;
    public function collideHandler(object1:ArcadeColliderType, ?object2:ArcadeColliderType, collideCallback:ArcadePhysicsCallback, processCallback:ArcadePhysicsCallback, callbackContext:Dynamic, overlapOnly:Bool):Bool;
    public function collideSpriteVsSprite(sprite1:phaser.gameobjects.GameObject, sprite2:phaser.gameobjects.GameObject, collideCallback:ArcadePhysicsCallback, processCallback:ArcadePhysicsCallback, callbackContext:Dynamic, overlapOnly:Bool):Bool;
    public function collideSpriteVsGroup(sprite:phaser.gameobjects.GameObject, group:phaser.gameobjects.Group, collideCallback:ArcadePhysicsCallback, processCallback:ArcadePhysicsCallback, callbackContext:Dynamic, overlapOnly:Bool):Bool;
    public function collideGroupVsTilemapLayer(group:phaser.gameobjects.Group, tilemapLayer:Dynamic, collideCallback:ArcadePhysicsCallback, processCallback:ArcadePhysicsCallback, callbackContext:Dynamic, overlapOnly:Bool):Bool;
    public function collideSpriteVsTilemapLayer(sprite:phaser.gameobjects.GameObject, tilemapLayer:Dynamic, collideCallback:ArcadePhysicsCallback, processCallback:ArcadePhysicsCallback, callbackContext:Dynamic, overlapOnly:Bool):Bool;
    public function collideGroupVsGroup(group1:phaser.gameobjects.Group, group2:phaser.gameobjects.Group, collideCallback:ArcadePhysicsCallback, processCallback:ArcadePhysicsCallback, callbackContext:Dynamic, overlapOnly:Bool):Bool;
    public function wrap(object:Dynamic, ?padding:Float):Void;
    public function wrapArray(objects:Array<Dynamic>, ?padding:Float):Void;
    public function wrapObject(object:Dynamic, ?padding:Float):Void;
}
